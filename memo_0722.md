### 리스트

여러 개의 값을 순서대로 저장하는, **변경 가능한(mutable)** 시퀀스 자료형 → 수정, 추가, 삭제 가능(문자열의 불변성과는 상반)

- 대괗로[] 안에 값들을 쉼표(,)로 구분하여 만듦
- 숫자, 문자열, 심지어 다른 리스트까지 **모든 종류의** 데이터를 담을 수 있음
- 값을 추가, 수정, 삭제하는 등자유롭게 변경할 수 있음
- 인덱싱으로 1개씩 값 수정 가능
- 슬라이싱으로 여러 값 한번에 수정 가능

**리스트의 시퀀스 특정**

- 리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능

**중첩 리스트**

다른 리스트를 값으로 가진 리스트 (중첩 : 어떤 자료 구조 안에 같은 종류의 자료 구조가 포함된 형태)

- 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있음
1. 먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택
    - my_list[4] → [’hello’, ‘world’, ‘!!!’]
2. 선택된 안쪽 리스트에 다시 한번 인덱스를 사용
    - my_list[4][-1] → ‘!!!’

※ 문자열도 엄연한 시퀀스 인거 주의!!

### 튜플

여러 개의 값을 순서대로 저장하는 **변경 불가능한** 시퀀스 자료형

- 소괄호 () 안에 값들을 쉼표(,)로 구분하여 만듦 (소괄호 없이도 만들기 가능)
- 모든 종류의 데이터를 담을 수 있음
- 리스트와 겨의 모든 변에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 결정적인 차이가 있음.

※단일 요소 튜플을 만들때는 반드시 후행쉼표를 해줘야 한다.

- 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용됨
- 다중 할당, 값 교환, 함수 다중 반환 값 등

### range

연속된 정수 시퀀스를 생성하는, **변경 불가능한** 자료형

- 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 매우 유용합니다.
- 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 ‘규칙’만 기억하여 메모리를 매우 효율적으로 사용한다.

**range 기본 구문**

- range()는 1개, 2개, 또는 3개의 매개변수(인자)를 가질 수 있습니다.
    
    range(start, stop, step)
    

![설명](image//image_1.png)


**range규칙**

1. 값의 범위 규칙
- stop 값은 생성되는 시퀀스에 절대 포함되지 않음
- range(1,5)는 1부터 5전까지 이므로 1,2,3,4가 생성
1. 증가/감소 값 규칙
- step 값은 숫자 시퀀스의 간격과 방향을 결정
    1. step이 양수일 때(기본값 :1)
    - 숫자가 start부터 stop을 향해 증가
    - range(1, 10, 2) → 1, 3, 5, 7, 9
    1. setp이 음수일 때
    - 숫자가 start부터 stop을 향해 감소
    - 이 경우, start 값은 stop 값보다 반드시 커야 함
    - range(10, 1, -2) → 10, 8, 6, 4, 2

### dict

key - value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형

순서가 없으므로 인덱스가 없음 …. 접근은 어떻게??? → **key**로 값에 접근한다!!

**딕셔너리 표현**

- 중괄호 {} 안에 값들이 쉼표(,)로 구분
- 값 1개는 키와 값이 쌍으로 이루어져 있음
- Key(키) - 값을 식별하기 위한 고유한 **이름표**
- Value(값) - 키에 해당하는 실제 데이터
- 각 값에는 순서가 없음

**Key의 규칙**

- 고유해야함(key는 중복x)
- 변경 불가능한 자료형만 사용 가능
O : str, int ,float, tuple
X : list, dict

**딕셔너리 값 접근 방법**

- key를 사용하여 해당 value 를 꺼내 올 수 있음
- key에 접근시 대괄호 [] 사용

**딕셔너리 값 추가 및 변경**

딕셔너리의 key는 불변이지만, 딕셔너리 자체는 가변이므로 값을 추가하거나 변경이 가능

![설명](image//image_2.png)

※딕셔너리는 차후에 API 개발할 때 사용(데이터 접근할 때 key를 이용해 접근할 경우가 많으므로…)

### 세트

순서와 중복이 없는 변경 가능한 자료형 (딕셔너리에서 키-값 쌍이 없음 / 순서가 없으미 시퀀스는 아님)

**세트 표현**

- 중괄호 {} 안에 값들을 쉼표(,)로 구분하여 만듦
- 수학에서의 집합과 동일한 연산 처리 가능

**세트의 두 가지 핵심 특징**

1. 중복을 허용하지 않음
- 똑값은 값은 단 하나만 존재할 수 있음
1. 순서가 없음
- 인덱싱(set[0])이나 슬라이싱(set[0:2])을 사용할 수 없음.

### other types

**None**

파이썬에서 ‘값이 없음’을 표현하는 특별한 데이터 타입

- 마치 내용물이 없는 ‘빈 상자’와 같습니다.
- 숫자 0이나 빈 문자열(’ ‘)과는 다른, ‘값이 존재하지 않음’ 또는 ‘아직 정해지지 않음’이라는 상태를 나타내기 위해 사용된다.

**Boolean**

‘참(True)’ 과 ‘거짓(False)’ 단 두가지 값만 가지는 데이터 타임

- 마치 ‘ON / OFF’ 스위치처럼, 프로그램의 흐름을 제어하는 조건문에서 ‘맞다’ 또는 ‘틀리다’ 를 판단하는 역할을 한다.

**Collection** 

여러 개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말

- 여러 물건을 담는 ‘보관함’ 과 같으며, 파이썬은 목적에 따라 다양한 종류의 컬렉션을 제공
- str ,list, tuple, range, set, dict 데이터 타입이 모두 Collection에 분류된다.

![설명](image//image_3.png)

### 형변환

한 데이터 타입을 다른 데이터 타입으로 변환하는 과정

- 예를 들어, 문자열 “100”을 숫자 100으로 바꾸거나, 숫자 3.14를 정수 3으로 바꾸는 등 데이터의 ‘형태’를 필요에 따라 바꾸느 것입니다.
- 형변환은 2가지가 있다
1. 암시적 형변환 
파이썬이 연산중에 자동으로 데이터 타입을 변환하는 것
2. 명시적 형변환 
개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것 
서로 다른 타입의 데이터를 ‘호환’되도록 맞추는 과정
int() , float(), str(), list(), tuple(), set() 같이 함수로 변환하고 싶은 타입의 데이터를 대입

### 연산자

**산술 연산자**

- 수학적 계산을 위해 사용되는 연산자

**복합 연산자**

- 연산과 할당이 함께 이루어짐
- += | a+=b | a = a + b
- -=  | a -=b | a = a - b
- *=  | a *=b | a = a * b
- /=  | a /=b | a = a / b
- //= | a // b | a = a //b
- %= | a %=b | a = a % b
- ** = | a ** b | = a = a **b

**비교 연산자**

- < 미만
    
     ≤ 이하
    > 초과
     ≥ 이상
     == 같음
     ! = 같지 않음
     is 같음
     is not 같지 않음
    

**== 연산자**

- 값이 같은지를 비교
- 동등성(equality)
- 예를 들어, 1 == Ture의 경우 파이썬이 내부적으로 True를 1로 간주할 수 있으므로 True 결과가 나옴

**is 연산자**

- 객체 자체가 같은지를 비교
- 식별성(identity)
- 두 변수가 완전히 동일한 객체를 가리키는지, 즉 **메모리 주소**가 같은지를 확인할 때 사용
- 프로그램에 오직 1개만 존재하도록 만든 싱글턴객체(None, True, False) 비교에 적합

**==와 is 정리**

- 값 비교에는 ==을 사용하고, 객체(레퍼런스) 비교에는 is를 사용하는 것이 원칙
- 숫자나 문자열, 불리언 값 등 동등성(값)을 판단해야 할 때 is를 쓰면 의도치 않은 결과(False)가 나올 수 있으며, 이는 파이썬 
내부의 최적화나 타입 차이로 인해 일관성이 꺠질 수 있기 때문
- is는 주로 싱글턴 객체에 대한 비교 시 사용

**논리 연산자**

여러 개의 조건을 조합하거나, Ture/False 값을 반대로 뒤집을 때 사용

- and : 논리곱 - 두 피연산자 모두 True인 경우에만 전체 표현식을 True로 평가
- or : 논리합 - 두 피연산자 중 하나라도 True인 경우 전체 표현식을 True로 평가\
- not : 논리부정 - 단일 피연산자를 부정

**단축 평가**

논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

하는 이유)

- 코드 실행을 최적화 하고, 불필요한 연산을 피하기 위해
- 단순히 True/False 논리 연산을 넘어, 이처럼 코드의 흐름을 제어하고, 오류를 방지하며 간결한 코드를 작성하는데 
매우 유용하게 사용되는 파이썬의 중요한 기능

**단축 평가 동작 정리**

- and 연산자
하나라도 거짓이면 바로 거짓
연산을 왼쪽에서 오른쪽으로 진행하다가 처음 만나는 거짓 값을 바로 반환
끝까지 갔는데 모든 값이 참이면, 맨 마지막 참 값을 반환
- or 연산자
하나라도 참이면 바로 참
or는 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 참 값을 바로 반환
만약 끝까지 갔는데 모든 값이 거짓이면, 맨 마지막 거짓 값을 반환

**파읶썬의 참과 거짓에 대한 새로운 시각**

- **거짓**으로 취급 되는 값들
False, 숫자 0, 빈 문자열 “” , 빈 리스트[], None 등 ‘비어있거나 없다’는 느낌의 값들
- **참**으로 취급되는 값들
Ture 그리고 ‘거짓’이 아닌 모든 값
1, -10 , “hello”, [1,2]등 내용이 있는 값

**멤버십 연산자**

특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자

- in : 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스의 속하는지를 확인
- not in : 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지를 확인

**시퀀스형 연산자**

- 시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자
- ‘+’는 시퀀스를 연결하는 기능을, ‘*”는 시퀀스를 반복하는 기능을 한다.  
+ : 결합 연산자 , * : 반복 연산자